<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<script>// Make *any* pre with class 'sagecell-sage' an executable Sage cell
// Their results will be linked, only within language type
sagecell.makeSagecell({inputLocation: 'pre.sagecell-sage',
                       linked: true,
                       languages: ['sage'],
                       evalButtonText: 'Evaluate (Sage)'});
</script><script>// Make *any* pre with class 'sagecell-python' an executable Sage cell
// Their results will be linked, only within language type
sagecell.makeSagecell({inputLocation: 'pre.sagecell-python',
                       linked: true,
                       languages: ['python'],
                       evalButtonText: 'Evaluate (Python)'});
</script>
</head>
<body class="ignore-math">
<h2 class="heading"><span class="type">Paragraph</span></h2>
<div class="para logical"><dl class="description-list">
<dt>Accessing Python</dt>
<dd><div class="para logical">
<div class="para">In addition to the SageMath cellls included throughout the book, there are a number of ways to access Python.</div>
<ol class="lower-alpha">
<li><div class="para">There is a freely available Sage cell at <a class="external" href="https://sagecell.sagemath.org/" target="_blank"><code class="code-inline tex2jax_ignore">sagecell.sagemath.org</code></a>.</div></li>
<li><div class="para">You can save your Sage work by creating an account at <a class="external" href="https://cocalc.com" target="_blank"><code class="code-inline tex2jax_ignore">cocalc.com</code></a> and working in a Sage worksheet.</div></li>
</ol>
</div></dd>
<dt>Creating matrices</dt>
<dd>
<div class="para logical">
<div class="para">There are a couple of ways to create matrices.  For instance, the matrix</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{bmatrix}
-2 \amp 3 \amp 0 \amp 4 \\
1 \amp -2 \amp 1 \amp -3 \\
0 \amp 2 \amp 3 \amp 0 \\
\end{bmatrix}
\end{equation*}
</div>
<div class="para">can be created in either of the two following ways.</div>
<ol class="lower-alpha">
<li><div class="para"><pre class="ptx-sagecell sagecell-python" id="sage-298"><script type="text/x-sage"></script></pre></div></li>
<li><div class="para"><pre class="ptx-sagecell sagecell-python" id="sage-299"><script type="text/x-sage"></script></pre></div></li>
</ol>
</div>
<div class="para">Be aware that Python can treat mathematically equivalent matrices in different ways depending on how they are entered. For instance, the matrix <pre class="ptx-sagecell sagecell-python" id="sage-300"><script type="text/x-sage"></script></pre> has integer entries while <pre class="ptx-sagecell sagecell-python" id="sage-301"><script type="text/x-sage"></script></pre> has floating point entries. If any of the entries in a matrix are provided as floating point numbers, then all of the entries will be converted to floating point values.</div>
</dd>
<dt>Special matrices</dt>
<dd><div class="para">The <span class="process-math">\(4\times 4\)</span> identity matrix can be created with the curiously named function <code class="code-inline tex2jax_ignore">np.eye()</code>.  This has nothing to do with eyes, but is a play on the pronunciation of $\bm I$. <pre class="ptx-sagecell sagecell-python" id="sage-302"><script type="text/x-sage"></script></pre> A diagonal matrix can be created from a list of its diagonal entries.  For instance, <pre class="ptx-sagecell sagecell-python" id="sage-303"><script type="text/x-sage"></script></pre>
</div></dd>
<dt>Reduced row echelon form</dt>
<dd><div class="para">The reduced row echelon form of a matrix can be obtained using the <code class="code-inline tex2jax_ignore">rref()</code> method after converting our matrix to a <code class="code-inline tex2jax_ignore">sympy.Matrix</code>. For instance, <pre class="ptx-sagecell sagecell-python" id="sage-304"><script type="text/x-sage"></script></pre>
</div></dd>
<dt>Vectors</dt>
<dd><div class="para">Numpy arrays do not need to be 2-dimensional. A vector is defined by listing its components. Notice that the shape of <code class="code-inline tex2jax_ignore">v</code> is a 1-tuple. <pre class="ptx-sagecell sagecell-python" id="sage-305"><script type="text/x-sage"></script></pre>
</div></dd>
<dt>Addition</dt>
<dd><div class="para">The <code class="code-inline tex2jax_ignore">+</code> operator performs vector and matrix addition. <pre class="ptx-sagecell sagecell-python" id="sage-306"><script type="text/x-sage"></script></pre> <pre class="ptx-sagecell sagecell-python" id="sage-307"><script type="text/x-sage"></script></pre>
</div></dd>
<dt>Multiplication</dt>
<dd>
<div class="para">From a mathematical perspecitve, the <code class="code-inline tex2jax_ignore">*</code> operator performs scalar multiplication of vectors and matrices. <pre class="ptx-sagecell sagecell-python" id="sage-308"><script type="text/x-sage"></script></pre>
</div>
<div class="para">Computationally, numpy is using something called <dfn class="terminology">broadcasting</dfn>, which is more general than scalar multiplication. When two numpy arrays have different shapes, numpy starts from the end of the shape tuples and compares their values.  If they match, thatâ€™s good.  But it is also OK if one of them is 1 (or non-existant, which amounts to nearly the samething) and the other is not.  In this case, we can imagine duplicating the array with 1 in that dimension to fill out its shape to match the other. (Numpy does not actually do this duplication, since that would be ineffcient, but it is a good mental model for how the operation behaves.) Working from back to front, each axis is considered, and in the end, if the shapes are compatible, they can be treated as if they had the same shape.  At that point, the opreation proceeds element by element in the expanded arrays.</div>
<div class="para">You can find out much more about broadcasting at <a class="external" href="https://numpy.org/doc/stable/user/basics.broadcasting.html" target="_blank"><code class="code-inline tex2jax_ignore">https://numpy.org/doc/stable/user/basics.broadcasting.html</code></a>.</div>
<div class="para">Broadcasting means that <code class="code-inline tex2jax_ignore">*</code> cannot be used for for matrix-vector and matrix-matrix multiplication in the linear algebra sense.  Instead we use <code class="code-inline tex2jax_ignore">@</code>. <pre class="ptx-sagecell sagecell-python" id="sage-309"><script type="text/x-sage"></script></pre>
</div>
</dd>
<dt>Operations on vectors</dt>
<dd><div class="para logical"><ol class="lower-alpha">
<li>
<div class="para">The length of a vector <code class="code-inline tex2jax_ignore">v</code> is found using <code class="code-inline tex2jax_ignore">np.linalg.norm()</code>. <pre class="ptx-sagecell sagecell-python" id="sage-310"><script type="text/x-sage">v = np.array([3, 4])
np.linalg.norm(v)
</script></pre>
</div>
<div class="para">Actually, <code class="code-inline tex2jax_ignore">np.linalg.norm()</code> can compute many different norms of both vectors and matrices.</div>
</li>
<li><div class="para">The dot product of two vectors <code class="code-inline tex2jax_ignore">v</code> and <code class="code-inline tex2jax_ignore">w</code> is <code class="code-inline tex2jax_ignore">v@w</code>.</div></li>
</ol></div></dd>
<dt>Operations on matrices</dt>
<dd><div class="para logical"><ol class="lower-alpha">
<li><div class="para">The transpose of a matrix <code class="code-inline tex2jax_ignore">A</code> is obtained using either <code class="code-inline tex2jax_ignore">A.transpose()</code> or <code class="code-inline tex2jax_ignore">A.T</code>.</div></li>
<li><div class="para">The inverse of a matrix <code class="code-inline tex2jax_ignore">A</code> is obtained using either <code class="code-inline tex2jax_ignore">A.inverse()</code> or <code class="code-inline tex2jax_ignore">A^-1</code>.</div></li>
<li><div class="para">The determinant of <code class="code-inline tex2jax_ignore">A</code> is <code class="code-inline tex2jax_ignore">np.linalg.det(A)</code>.</div></li>
<li><div class="para">A basis for the null space <span class="process-math">\(\nul(A)\)</span> is found with <code class="code-inline tex2jax_ignore">A.right_kernel()</code>.</div></li>
<li><div class="para">Pull out a column of <code class="code-inline tex2jax_ignore">A</code> using, for instance, <code class="code-inline tex2jax_ignore">A[:, 0]</code>, which returns the vector that is the first column of <code class="code-inline tex2jax_ignore">A</code>.</div></li>
<li><div class="para">The command <code class="code-inline tex2jax_ignore">A.matrix_from_columns([0,1,2])</code> returns the matrix formed by the first three columns of <code class="code-inline tex2jax_ignore">A</code>.</div></li>
</ol></div></dd>
<dt>Eigenvectors and eigenvalues</dt>
<dd><div class="para logical"><ol class="lower-alpha">
<li><div class="para">The eigenvalues of a matrix <code class="code-inline tex2jax_ignore">A</code> can be found with <code class="code-inline tex2jax_ignore">A.eigenvalues()</code>. The number of times that an eigenvalue appears in the list equals its multiplicity.</div></li>
<li><div class="para">The eigenvectors of a matrix having rational entries can be found with <code class="code-inline tex2jax_ignore">A.eigenvectors_right()</code>.</div></li>
<li><div class="para">If <span class="process-math">\(A\)</span> can be diagonalized as <span class="process-math">\(A=PDP^{-1}\text{,}\)</span> then <pre class="ptx-sagecell sagecell-python" id="sage-311"><script type="text/x-sage"></script></pre> provides the matrices <code class="code-inline tex2jax_ignore">D</code> and <code class="code-inline tex2jax_ignore">P</code>.</div></li>
<li><div class="para">The characteristic polynomial of <code class="code-inline tex2jax_ignore">A</code> is <code class="code-inline tex2jax_ignore">A.charpoly('x')</code> and its factored form <code class="code-inline tex2jax_ignore">A.fcp('x')</code>.</div></li>
</ol></div></dd>
<dt>Matrix factorizations</dt>
<dd><div class="para logical"><ol class="lower-alpha">
<li><div class="para">The <span class="process-math">\(LU\)</span> factorization of a matrix <pre class="ptx-sagecell sagecell-python" id="sage-312"><script type="text/x-sage"></script></pre> gives matrices so that <span class="process-math">\(PA = LU\text{.}\)</span>
</div></li>
<li><div class="para">A singular value decomposition is obtained with <pre class="ptx-sagecell sagecell-python" id="sage-313"><script type="text/x-sage"></script></pre> Itâ€™s important to note that the matrix must be defined using <code class="code-inline tex2jax_ignore">RDF</code>.  For instance, <code class="code-inline tex2jax_ignore">A = matrix(RDF, 3,2,[1,0,-1,1,1,1])</code>.</div></li>
<li><div class="para">The <span class="process-math">\(QR\)</span> factorization of <code class="code-inline tex2jax_ignore">A</code> is <code class="code-inline tex2jax_ignore">A.QR()</code> provided that <code class="code-inline tex2jax_ignore">A</code> is defined using <code class="code-inline tex2jax_ignore">RDF</code>.</div></li>
</ol></div></dd>
</dl></div>
<span class="incontext"><a href="app-python-reference.html#p-8512" class="internal">in-context</a></span>
</body>
</html>
