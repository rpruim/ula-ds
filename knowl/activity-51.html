<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<script>// Make *any* pre with class 'sagecell-python' an executable Sage cell
// Their results will be linked, only within language type
sagecell.makeSagecell({
  "inputLocation": "pre.sagecell-python",
  "linked": true,
  "linkKey": "linked-python",
  "autoeval": false,
  "languages": [
    "python"
  ],
  "evalButtonText": "Evaluate (Python)"
});
</script><script>// Make *any* pre with class 'sagecell-python-autoeval' an executable Sage cell
// Their results will be linked, only within language type
sagecell.makeSagecell({
  "inputLocation": "pre.sagecell-python-autoeval",
  "linked": true,
  "linkKey": "linked-python",
  "autoeval": true,
  "languages": [
    "python"
  ],
  "evalButtonText": "Evaluate (Python)",
  "hide": [
    "evalButton"
  ]
});
</script>
</head>
<body class="ignore-math">
<article class="activity project-like"><h4 class="heading">
<span class="type">Activity</span><span class="space"> </span><span class="codenumber">5.2.5</span><span class="period">.</span>
</h4>
<div class="para logical">
<div class="para">We will use Python to find the eigenvalues and eigenvectors of a matrix.  Let’s begin with the matrix <span class="process-math">\(A = \left[\begin{array}{rr}
-3 \amp 1 \\
0 \amp -3 \\
\end{array}\right]
\text{.}\)</span>
</div>
<ol class="lower-alpha">
<li>
<div class="para">We can find the characteristic polynomial of a <code class="code-inline tex2jax_ignore">sympy.Matrix</code> <code class="code-inline tex2jax_ignore">A</code> by writing <code class="code-inline tex2jax_ignore">A.charpoly('lambda')</code>.  Notice that we have to give Python a variable in which to write the polynomial;  here, we use <code class="code-inline tex2jax_ignore">lambda</code> though <code class="code-inline tex2jax_ignore">x</code> works just as well.</div>
<pre class="ptx-sagecell sagecell-python-autoeval" id="sage-152"><script type="text/x-sage">import numpy as np
import sympy
import scipy
</script></pre>
<pre class="ptx-sagecell sagecell-python" id="sage-153"><script type="text/x-sage">A = np.array([[-3,1],[0,-3]])
M = sympy.Matrix(A)
p = M.charpoly('lambda')
print(p)
</script></pre>
<div class="para">The factored form of the characteristic polynomial may be more useful since it will tell us the eigenvalues and their multiplicities.  The factored characteristic polynomial is found with <code class="code-inline tex2jax_ignore">sympy.factor()</code>.</div>
<pre class="ptx-sagecell sagecell-python" id="sage-154"><script type="text/x-sage">A = np.array([[-3, 1], [0, -3]])
M = sympy.Matrix(A)
p = M.charpoly('x')
print(sympy.factor(p)); print()
print(sympy.factor(p.as_expr()))
</script></pre>
</li>
<li>
<div class="para">If we only want the eigenvalues, we can use <code class="code-inline tex2jax_ignore">numpy.linalg.eigvals()</code> or <code class="code-inline tex2jax_ignore">scipy.linalg.eigvals()</code>. </div>
<pre class="ptx-sagecell sagecell-python" id="sage-155"><script type="text/x-sage">A = np.array([[-3, 1], [0, -3]])
print(np.linalg.eigvals(A))
</script></pre>
<div class="para">Notice that the multiplicity of an eigenvalue is the number of times it is repeated in the list of eigenvalues.</div>
</li>
<li>
<div class="para">Finally, we can find both eigenvalues and (right) eigenvectors using <code class="code-inline tex2jax_ignore">numpy.linalg.eig(A)</code> or <code class="code-inline tex2jax_ignore">scipy.linalg.eig(A)</code>. </div>
<aside class="aside aside-like"><h5 class="heading"><span class="title">Left and right eigenvectors.</span></h5>
<div class="para">Technically, we are finding <dfn class="terminology">right eigenvectors</dfn> since the vector <span class="process-math">\(\vvec\)</span> appears to the right of <span class="process-math">\(A\)</span> in the definition <span class="process-math">\(A\vvec=\lambda \vvec\text{.}\)</span> That’s most often what we want.  But we can also get <dfn class="terminology">left eigenvectors</dfn> with <code class="code-inline tex2jax_ignore">scipy.linalg.eig(A, left = True)</code>. Feel free to try it in the code chunk below. NumPy does not provide this option.</div></aside><pre class="ptx-sagecell sagecell-python" id="sage-156"><script type="text/x-sage">A = np.array([[-3, 1], [0, -3]])
evals, evecs = scipy.linalg.eig(A) 
print(evals); print()
print(evecs.round(10))
</script></pre>
<div class="para">The first item in the tuple returned gives the eigenvalues, the second the eigenvectors.</div>
</li>
<li><div class="para logical">
<div class="para">When working with decimal entries, which are called <dfn class="terminology">floating point numbers</dfn> in computer science, we must remember that computers perform only approximate arithmetic. This can be a problem when we wish to find the eigenvectors of a matrix.  To illustrate, consider the matrix <span class="process-math">\(A=\left[\begin{array}{rr}
0.4 \amp 0.3 \\
0.6 \amp 0.7 \\
\end{array}\right]
\text{.}\)</span>
</div>
<ol class="decimal">
<li><div class="para">Without using Python, find the eigenvalues of this matrix.</div></li>
<li><div class="para">What do you find for the reduced row echelon form of <span class="process-math">\(A-I\text{?}\)</span>
</div></li>
<li>
<div class="para">Let’s now use Python to determine the reduced row echelon form of <span class="process-math">\(A-I\text{:}\)</span>
</div>
<pre class="ptx-sagecell sagecell-python" id="sage-157"><script type="text/x-sage">A = sympy.Matrix([[0.4,0.3],[0.6,0.7]])
print((A - sympy.eye(2)).rref())   # use sympy.eye() to get a sympy.Matrix
</script></pre>
<div class="para">What result does Python report for the reduced row echelon form?  Why is this result not correct? (Hint: compute row and column sums.)</div>
</li>
<li>
<div class="para">Despite the error in finding the reduce row echelon form, NumPy and SciPy <em class="emphasis">can</em> compute these eigenvalues and eigenvectors for us.</div>
<pre class="ptx-sagecell sagecell-python" id="sage-158"><script type="text/x-sage">A = np.array([[0.4, 0.3],[0.6,0.7]])
print(np.linalg.eig(A))
</script></pre>
<div class="para">As you might expect, this implies that the method being used does not rely on using RREF along the way. RREF is not numerically stable, this is why it is not included in numpy and scipy.</div>
</li>
<li>
<div class="para">If we provide sympy with rational values instead of floating point, then it can compute the RREF of our matrix exactly and the error from above goes away.</div>
<pre class="ptx-sagecell sagecell-python" id="sage-159"><script type="text/x-sage">from sympy import Rational as r
A = sympy.Matrix([[r(4,10),r(3,10)],[r(6,10),r(7,10)]])
print(A)
print(A.eigenvals())
</script></pre>
<div class="para">In <a href="chap6.html" class="internal" title="Chapter 6: Orthogonality and Least Squares">Chapter 6</a> we will see other methods for computing eigevectors that do not rely on RREF.</div>
</li>
</ol>
</div></li>
</ol>
</div>
<div class="solutions"><a href="" class="solution-knowl original" data-knowl="./knowl/solution-216-hidden.html" title="Solution 5.2.5.1"><span class="type">Solution</span><span class="period">.</span></a></div></article><span class="incontext"><a href="sec-eigen-find.html#activity-51" class="internal">in-context</a></span>
</body>
</html>
