<?xml version="1.0" encoding="UTF-8"?>

<appendix xml:id="app-python-reference"
	  xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>
    Python Reference
  </title>

  <p>
    As we have introduced a number of Python commands throughout the
    text, it may be helpful to have the most important ones summarized
    in a single place.  That is the aim of this appendix.
  </p>

  <p>
	There are many other sources of information about Python and its 
	various modules. Numpy's 
	<url href="https://numpy.org/doc/stable/user/absolute_beginners.html" 
	     visual = "absolute basics for beginners" /> 
		 is a good place to start
		 for more information about numpy in particular.
  </p>

  <p>
    <dl>
      <li><title> Accessing Python </title>
      <p> In addition to the SageMath cellls included throughout the book,
      there are a number of ways to access Python. 
      <ol marker="a.">
	<li><p> There is a freely available Sage cell at  
	<url href="https://sagecell.sagemath.org/"
	     visual="sagecell.sagemath.org" />.
	</p></li>
	<li><p> You can save your Sage work by creating an account at
	<url href="https://cocalc.com"
	     visual="cocalc.com"/>
	and working in a Sage worksheet.
	</p></li>
      </ol>
      </p></li>

      <li><title> Creating matrices </title>
      <p> There are a couple of ways to create matrices.  For
      instance, the matrix
      <me>
	\begin{bmatrix}
	-2 \amp 3 \amp 0 \amp 4 \\
	1 \amp -2 \amp 1 \amp -3 \\
	0 \amp 2 \amp 3 \amp 0 \\
	\end{bmatrix}
      </me>
      can be created in either of the two following ways.
	<ol marker="a.">
	  <li> <p>
	    <sage language="python">
A = np.array([ 
    [-2, 3, 0, 4],
    [ 1,-2, 1,-3],
	[ 0, 2, 3, 0] 
	])
	    </sage>
	  </p>
	  </li>
	  <li> <p>
	    <sage language="python">
A = np.array([-2, 3, 0, 4, 1,-2, 1,-3, 0, 2, 3, 0])
A.shape = (3, 4)  # change the shape to be 3 x 4
	    </sage>
	  </p>
	  </li>
	</ol>
      </p>
      <p>
	Be aware that Python can treat mathematically equivalent
	matrices in different ways depending on how they are entered. 
	For instance, the matrix
	<sage language="python">
nd.array([ [1, 2],
           [2, 1] ])
	</sage>
	has integer entries while
	<sage language="python">
nd.array([ [1.0, 2.0],
           [2.0, 1.0] ])
	</sage>
	has floating point entries. If any of the entries in a matrix are provided as 
	floating point numbers, then all of the entries will be converted to floating point values.
      </p>

      </li>

      <li>
	<title> Special matrices </title>
	<p>
	  The <m>4\times 4</m> identity matrix can be created with the curiously named function 
	  <c>np.eye()</c>.  This has nothing to do with eyes, but is a play on the pronunciation of $\bm I$.
	  <sage language="python">
np.eye(4)
	  </sage>
	  A diagonal matrix can be created from a list of its diagonal entries.  For instance,
	  <sage language="python">
np.diag([3,-4,2])	    
	  </sage>
	</p>
      </li>
      <li>
	<title>Reduced row echelon form</title>
	<p>
	  The reduced row echelon form of a matrix can be obtained
	  using the <c>rref()</c> method after converting our matrix to a <c>sympy.Matrix</c>. 
	  For instance,
	  <sage language="python">
A = np.array([ [1,2], [2,1] ])
sympy.Matrix(A).rref()
	  </sage>
	</p>
      </li>

      <li>
	<title>Vectors</title>
	<p>
	  Numpy arrays do not need to be 2-dimensional. A vector is defined by listing its components.
	  Notice that the shape of <c>v</c> is a 1-tuple.
	  <sage language="python">
v = np.array([3,-1,2])
v.shape()
	  </sage>
	</p>
      </li>

      <li>
	<title> Addition </title>
	<p> The <c>+</c> operator performs vector and matrix
	addition.
	<sage language="python">
v = np.array([2,1])
w = np.array([-3,2])
print(v+w)
	</sage>
	<sage language="python">
A = np.array([[2,-3],[1,2]])
B = np.array([[-4,1],[3,-1]])
print(A+B)
	</sage>
	</p>
      </li>

      <li>
	<title> Multiplication </title>
	<p>
	  From a mathematical perspecitve, the <c>*</c> operator performs scalar multiplication of
	  vectors and matrices.
	  <sage language="python">
v = np.array([2,1])
print(3*v)
A = np.array([[2,1],[-3,2]])	    
print(3*A)
	  </sage>
	  </p>
		
	  <p>
	  Computationally, numpy is using something called <term>broadcasting</term>, which is more 
	  general than scalar multiplication. When two numpy arrays have different shapes, numpy starts
	  from the end of the shape tuples and compares their values.  If they match, that's good.  But it 
	  is also OK if one of them is 1 (or non-existant, which amounts to nearly the samething) and the 
	  other is not.  In this case, we can imagine duplicating the array with 1 in that dimension to fill 
	  out its shape to match the other. (Numpy does not actually do this duplication, since that would be 
	  ineffcient, but it is a good mental model for how the operation behaves.) Working from back to 
	  front, each axis is considered, and in the end, if the shapes are compatible, they can be treated 
	  as if they had the same shape.  At that point, the opreation proceeds element by element in the 
	  expanded arrays.
	  </p>

	  <p>
		You can find out much more about broadcasting at 
		<url href="https://numpy.org/doc/stable/user/basics.broadcasting.html" />.
	  </p>
	  
	<p>
	  Broadcasting means that <c>*</c> cannot be used for for matrix-vector and
	  matrix-matrix multiplication in the linear algebra sense.  Instead we use <c>@</c>.
	  <sage language="python">
A = np.array([[2,-3],[1,2]])
v = np.array([2,1])	    
print(A*v)  # component-wise after broadcasting
print(A@v)  # CORRECT way to do linear algebra
B = np.array([[-4,1],[3,-1]])
print(A*B)   # component-wise
print(A@B)   # linear algebra
	  </sage>
	</p>
      </li>

      <li>
	<title> Operations on vectors </title>
	<p>
	  <ol marker="a.">
	    <li>
	      <p>
		The length of a vector <c>v</c> is found using
		<c>np.linalg.norm()</c>.  

		<sage language="python">
		<input>
v = np.array([3, 4])
np.linalg.norm(v)
		</input>
		</sage>
	      </p>

		  <p>
			Actually, <c>np.linalg.norm()</c> can compute many different norms of 
		    both vectors and matrices.	
		  </p>
	    </li>
	    <li>
	      <p>
		The dot product of two vectors <c>v</c> and <c>w</c> is
		<c>v@w</c>.
	      </p>
	    </li>
	  </ol>
	</p>
      </li>

      <li>
	<title> Operations on matrices </title>
	<p><ol marker="a.">
	  <li>
	    <p> The transpose of a matrix <c>A</c> is obtained using either
	    <c>A.transpose()</c> or <c>A.T</c>.
	    </p>
	  </li>
	  <li>
	    <p> The inverse of a matrix <c>A</c> is obtained using either
	    <c>A.inverse()</c> or <c>A^-1</c>.
	    </p>
	  </li>
	  <li>
	    <p> The determinant of <c>A</c> is <c>np.linalg.det(A)</c>.
	    </p>
	  </li>
	  <li>
	    <p> A basis for the null space <m>\nul(A)</m> is found with
	    <c>A.right_kernel()</c>. </p>
	  </li>
	  <li>
	    <p>
	      Pull out a column of <c>A</c> using, for instance,
	      <c>A[:, 0]</c>, which returns the vector that is the
	      first column of <c>A</c>.
	    </p>
	  </li>
	  <li>
	    <p>
	      The command <c>A.matrix_from_columns([0,1,2])</c>
	      returns the matrix formed by the first three columns of
	      <c>A</c>.
	    </p>
	  </li>
	</ol>
	</p>
      </li>

      <li>
	<title> Eigenvectors and eigenvalues </title>
	<p>
	  <ol marker="a.">
	    <li>
	      <p>
		The eigenvalues of a matrix <c>A</c> can be found with
		<c>A.eigenvalues()</c>.
		The number of times that an eigenvalue appears in the list
		equals its multiplicity.
	      </p>
	    </li>
	    <li>
	      <p>
		The eigenvectors of a matrix having rational entries can be
		found with <c>A.eigenvectors_right()</c>.
	      </p>
	    </li>
	    <li>
	      <p>
		If <m>A</m> can be diagonalized as <m>A=PDP^{-1}</m>, then
		<sage language="python">
D, P = A.right_eigenmatrix()
		</sage>
		provides the matrices <c>D</c> and <c>P</c>.
	      </p>
	    </li>
	    <li>
	      <p>
		The characteristic polynomial of <c>A</c> is
		<c>A.charpoly('x')</c>
		and its factored form
		<c>A.fcp('x')</c>.
	      </p>
	    </li>
	  </ol>
	</p>
      </li>
      <li>
	<title> Matrix factorizations </title>
	<p>
	  <ol marker="a.">
	    <li>
	      <p>
		The <m>LU</m> factorization of a matrix 
		<sage language="python">
P, L, U = A.LU()	    
		</sage>
		gives matrices so that <m>PA = LU</m>.
	      </p>
	    </li>
	    <li>
	      <p>
		A singular value decomposition is obtained with
		<sage language="python">
U, Sigma, V = A.SVD()	    
		</sage>
		It's important to note that the matrix must be defined using
		<c>RDF</c>.  For instance,
		<c>A = matrix(RDF, 3,2,[1,0,-1,1,1,1])</c>.
	      </p>
	    </li>
	    <li>
	      <p>
		The <m>QR</m> factorization of <c>A</c> is
		<c>A.QR()</c> provided that <c>A</c> is defined using
		<c>RDF</c>.
	      </p>
	    </li>
	  </ol>
	</p>
      </li>
    </dl>
  </p>
      

</appendix>

  
